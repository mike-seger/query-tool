springdoc.swagger-ui.path: /swagger-ui.html

spring:
  datasource:
    url: jdbc:h2:mem:querytool;DB_CLOSE_DELAY=-1
    driver-class-name: org.h2.Driver
    username: sa
    password:
    platform: h2
  h2:
    console:
      enabled: true

liquibase:
  change-log: classpath:/db/changelog/db.changelog-master.yaml

management:
  endpoints:
    web:
      exposure:
        include: "*"

com.net128.query-tool:
  custom-queries: true
  minTTL: PT0.2s
  maxTTL: 60m
  subquery_rented: |
      select inventory_id, count(*) rented
      from rental
      group by inventory_id
  queries:
    "[postgres:table counts]":
      sql: |
        select relname as table_name, n_live_tup as row_count
        from pg_stat_user_tables where schemaname=(select current_schema)
        order by row_count desc, table_name
    "[h2:table counts]":
      sql: |
        select table_name, row_count_estimate row_count
        from information_schema.tables
        where table_schema = 'PUBLIC'
        order by row_count desc, table_name
    "[postgres:table sizes]":
      sql: |
        select
          table_name as name,
          pg_relation_size(table_schema||'.'||table_name) as size,
          pg_size_pretty(pg_relation_size(table_schema||'.'||table_name)) as size_pretty
        from information_schema.tables
        where table_schema=(select current_schema)
        order by size desc
    "[postgres:activity]":
      sql: |  
        select *
        from pg_stat_activity
        where pg_stat_activity.query_start is not null
        order by backend_start
    "[current time]":
      minTTL: 10s
      maxTTL: 60m
      sql: |
        select current_timestamp
    "[postgres:locks]":
      sql: |
        select *
        from pg_locks
        join pg_stat_activity on pg_locks.pid = pg_stat_activity.pid
        order by backend_start desc
    "[top 100 rented]":
      sql: |
        select description, rented from
          (select film_id, rented from
            (select * from (
              ${com.net128.query-tool.subquery_rented}
            ) res
            order by rented desc
            limit 100) res2
          join inventory on res2.inventory_id = inventory.inventory_id) res3
        join film on res3.film_id = film.film_id
    "[h2:random data (auto_refresh)]":
      minTTL: 1s
      maxTTL: 10m
      sql: |
        select
          row_number() over () as id,
          to_char(current_timestamp, 'YYYY-MM-DD"T"HH24:MI:SS') as "timestamp",
          floor(random() * 1000) as "field1",  -- random integer between 0 and 999
          floor(random() * 1000) as "field2",  -- random integer between 0 and 999
          floor(random() * 1000) as "field3",  -- random integer between 0 and 999
          floor(random() * 1000) as "field4",  -- random integer between 0 and 999
          floor(random() * 1000) as "field5",  -- random integer between 0 and 999
          (select string_agg(substring('abcdefghijklmnopqrstuvwxyz', cast(floor(random() * 26) + 1 as int), 1), '')
            from (select 1 from information_schema.columns limit floor(random() * 10) + 1)) as "field6",  -- random string (1-10 chars)
          (select string_agg(substring('abcdefghijklmnopqrstuvwxyz', cast(floor(random() * 26) + 1 as int), 1), '')
            from (select 1 from information_schema.columns limit floor(random() * 10) + 1)) as "field7",  -- random string (1-10 chars)
          (select string_agg(substring('abcdefghijklmnopqrstuvwxyz', cast(floor(random() * 26) + 1 as int), 1), '')
            from (select 1 from information_schema.columns limit floor(random() * 10) + 1)) as "field8"   -- random string (1-10 chars)
        from (
        select 1
        from information_schema.columns  -- just a table with more than 10 rows
        limit 10  -- limit to 10 rows
        ) as temp
    "[postgres:random data (auto refresh)]":
      minTTL: 1s
      maxTTL: 10m
      sql: |
        with num_fields as (
          select
          row_number() over () as id,
            to_char(current_timestamp, 'YYYY-MM-DD"T"HH24:MI:SS') as "timestamp",
            floor(random() * 1000) as "field1",  -- random integer between 0 and 999
            floor(random() * 1000) as "field2",  -- random integer between 0 and 999
            floor(random() * 1000) as "field3",  -- random integer between 0 and 999
            floor(random() * 1000) as "field4",  -- random integer between 0 and 999
            floor(random() * 1000) as "field5"   -- random integer between 0 and 999
          from generate_series(1, 10)
        )
        select
          id,"timestamp","field1","field2","field3","field4","field5",
          md5("field1"::text || "field2"::text || random()::text) as "field6",  -- random string based on numeric "fields" and random()
          md5("field2"::text || "field3"::text || random()::text) as "field7",  -- another random string based on different numeric "fields"
          md5("field3"::text || "field4"::text || random()::text) as "field8"   -- yet another random string
        from num_fields